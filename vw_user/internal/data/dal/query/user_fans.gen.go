// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"vw_user/internal/data/dal/model"
)

func newUserFan(db *gorm.DB, opts ...gen.DOOption) userFan {
	_userFan := userFan{}

	_userFan.userFanDo.UseDB(db, opts...)
	_userFan.userFanDo.UseModel(&model.UserFan{})

	tableName := _userFan.userFanDo.TableName()
	_userFan.ALL = field.NewAsterisk(tableName)
	_userFan.UserID = field.NewInt64(tableName, "user_id")
	_userFan.FollowerID = field.NewInt64(tableName, "follower_id")
	_userFan.DeletedAt = field.NewField(tableName, "deleted_at")
	_userFan.UpdatedAt = field.NewTime(tableName, "updated_at")
	_userFan.CreatedAt = field.NewTime(tableName, "created_at")

	_userFan.fillFieldMap()

	return _userFan
}

// userFan 用户粉丝表
type userFan struct {
	userFanDo

	ALL        field.Asterisk
	UserID     field.Int64
	FollowerID field.Int64
	DeletedAt  field.Field
	UpdatedAt  field.Time
	CreatedAt  field.Time

	fieldMap map[string]field.Expr
}

func (u userFan) Table(newTableName string) *userFan {
	u.userFanDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userFan) As(alias string) *userFan {
	u.userFanDo.DO = *(u.userFanDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userFan) updateTableName(table string) *userFan {
	u.ALL = field.NewAsterisk(table)
	u.UserID = field.NewInt64(table, "user_id")
	u.FollowerID = field.NewInt64(table, "follower_id")
	u.DeletedAt = field.NewField(table, "deleted_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")
	u.CreatedAt = field.NewTime(table, "created_at")

	u.fillFieldMap()

	return u
}

func (u *userFan) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userFan) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 5)
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["follower_id"] = u.FollowerID
	u.fieldMap["deleted_at"] = u.DeletedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["created_at"] = u.CreatedAt
}

func (u userFan) clone(db *gorm.DB) userFan {
	u.userFanDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userFan) replaceDB(db *gorm.DB) userFan {
	u.userFanDo.ReplaceDB(db)
	return u
}

type userFanDo struct{ gen.DO }

type IUserFanDo interface {
	gen.SubQuery
	Debug() IUserFanDo
	WithContext(ctx context.Context) IUserFanDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserFanDo
	WriteDB() IUserFanDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserFanDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserFanDo
	Not(conds ...gen.Condition) IUserFanDo
	Or(conds ...gen.Condition) IUserFanDo
	Select(conds ...field.Expr) IUserFanDo
	Where(conds ...gen.Condition) IUserFanDo
	Order(conds ...field.Expr) IUserFanDo
	Distinct(cols ...field.Expr) IUserFanDo
	Omit(cols ...field.Expr) IUserFanDo
	Join(table schema.Tabler, on ...field.Expr) IUserFanDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserFanDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserFanDo
	Group(cols ...field.Expr) IUserFanDo
	Having(conds ...gen.Condition) IUserFanDo
	Limit(limit int) IUserFanDo
	Offset(offset int) IUserFanDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserFanDo
	Unscoped() IUserFanDo
	Create(values ...*model.UserFan) error
	CreateInBatches(values []*model.UserFan, batchSize int) error
	Save(values ...*model.UserFan) error
	First() (*model.UserFan, error)
	Take() (*model.UserFan, error)
	Last() (*model.UserFan, error)
	Find() ([]*model.UserFan, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserFan, err error)
	FindInBatches(result *[]*model.UserFan, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserFan) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserFanDo
	Assign(attrs ...field.AssignExpr) IUserFanDo
	Joins(fields ...field.RelationField) IUserFanDo
	Preload(fields ...field.RelationField) IUserFanDo
	FirstOrInit() (*model.UserFan, error)
	FirstOrCreate() (*model.UserFan, error)
	FindByPage(offset int, limit int) (result []*model.UserFan, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserFanDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userFanDo) Debug() IUserFanDo {
	return u.withDO(u.DO.Debug())
}

func (u userFanDo) WithContext(ctx context.Context) IUserFanDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userFanDo) ReadDB() IUserFanDo {
	return u.Clauses(dbresolver.Read)
}

func (u userFanDo) WriteDB() IUserFanDo {
	return u.Clauses(dbresolver.Write)
}

func (u userFanDo) Session(config *gorm.Session) IUserFanDo {
	return u.withDO(u.DO.Session(config))
}

func (u userFanDo) Clauses(conds ...clause.Expression) IUserFanDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userFanDo) Returning(value interface{}, columns ...string) IUserFanDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userFanDo) Not(conds ...gen.Condition) IUserFanDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userFanDo) Or(conds ...gen.Condition) IUserFanDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userFanDo) Select(conds ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userFanDo) Where(conds ...gen.Condition) IUserFanDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userFanDo) Order(conds ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userFanDo) Distinct(cols ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userFanDo) Omit(cols ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userFanDo) Join(table schema.Tabler, on ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userFanDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userFanDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userFanDo) Group(cols ...field.Expr) IUserFanDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userFanDo) Having(conds ...gen.Condition) IUserFanDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userFanDo) Limit(limit int) IUserFanDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userFanDo) Offset(offset int) IUserFanDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userFanDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserFanDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userFanDo) Unscoped() IUserFanDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userFanDo) Create(values ...*model.UserFan) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userFanDo) CreateInBatches(values []*model.UserFan, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userFanDo) Save(values ...*model.UserFan) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userFanDo) First() (*model.UserFan, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserFan), nil
	}
}

func (u userFanDo) Take() (*model.UserFan, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserFan), nil
	}
}

func (u userFanDo) Last() (*model.UserFan, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserFan), nil
	}
}

func (u userFanDo) Find() ([]*model.UserFan, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserFan), err
}

func (u userFanDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserFan, err error) {
	buf := make([]*model.UserFan, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userFanDo) FindInBatches(result *[]*model.UserFan, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userFanDo) Attrs(attrs ...field.AssignExpr) IUserFanDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userFanDo) Assign(attrs ...field.AssignExpr) IUserFanDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userFanDo) Joins(fields ...field.RelationField) IUserFanDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userFanDo) Preload(fields ...field.RelationField) IUserFanDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userFanDo) FirstOrInit() (*model.UserFan, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserFan), nil
	}
}

func (u userFanDo) FirstOrCreate() (*model.UserFan, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserFan), nil
	}
}

func (u userFanDo) FindByPage(offset int, limit int) (result []*model.UserFan, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userFanDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userFanDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userFanDo) Delete(models ...*model.UserFan) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userFanDo) withDO(do gen.Dao) *userFanDo {
	u.DO = *do.(*gen.DO)
	return u
}
